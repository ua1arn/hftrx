// https://dogbolt.org/

#include "hardware.h"
#include "formats.h"	// for PRINTF prints

#if WITHLTDCHW && WITHHDMITVHW && 1

/* This file was generated by the Hex-Rays decompiler version 8.4.0.240320.
 Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

 Detected compiler: GNU C++
 */
struct video_para;
struct audio_para;
struct hdmi_bsp_func;


enum audio_type
{
	PCM = 1,
	AC3,
	MPEG1,
	MP3,
	MPEG2,
	AAC,
	DTS,
	ATRAC,
	OBA,
	DDP,
	DTS_HD,
	MAT,
	DST,
	WMA_PRO,
};

static unsigned audio_vic;
static unsigned audio_ca;	// ????????
static unsigned audio_ch_num = 2;
static unsigned audio_sample_rate = 48000;
static unsigned audio_sample_bit = 24;
static unsigned audio_type = PCM;

//-------------------------------------------------------------------------
// Function declarations

static void hdmi_write(unsigned addr, uint8_t data);
static void hdmi_writel(unsigned addr, unsigned int data);
static unsigned int get_vid(unsigned int id);
static void hdmi_udelay(uint64_t us);
static void hdmi_mdelay(uint64_t ms);
static void hdmi_phy_init(void); // idb
static int64_t hdmi_read(unsigned addr);
static void bsp_hdmi_inner_init(void);
static int bsp_hdmi_set_func(struct hdmi_bsp_func *func);
int bsp_hdmi_set_bias_source(unsigned int src);
void bsp_hdmi_set_version(unsigned int version);
void bsp_hdmi_set_addr(uintptr_t base_addr);
static void bsp_hdmi_init(void);
static void bsp_hdmi_set_video_en(uint8_t enable);
static int bsp_hdmi_video_get_div(unsigned int pixel_clk);
static int bsp_hdmi_video(unsigned vic);
static int bsp_hdmi_audio(unsigned vic);
static int bsp_hdmi_ddc_read(char cmd, char pointer, char offset, int nbyte, char *pbuf);
static unsigned int bsp_hdmi_get_hpd(void);
static void bsp_hdmi_standby(void);
static void bsp_hdmi_hrst(void);
static int bsp_hdmi_hdcp_err_check(void);
static int bsp_hdmi_cec_get_simple_msg(uint8_t *msg);
static int bsp_hdmi_cec_send(char *buf, uint8_t bytes);
static void bsp_hdmi_cec_free_time_set(uint8_t value);
static int bsp_hdmi_cec_sta_check(void);


enum color_space {
	BT601 = 1,
	BT709,
	EXT_CSC,
};

struct para_tab
{
	unsigned int para[19];
};

struct pcm_sf
{
	unsigned int 	sf;
	unsigned char	cs_sf;
};

//-------------------------------------------------------------------------
// Data declarations

static struct para_tab ptbl [20] =
{
	{ { 6, 1, 1, 1, 5, 3, 0, 1, 4, 0, 0, 160, 20, 38, 124, 240, 22, 0, 0u } },
	{ { 21, 11, 1, 1, 5, 3, 1, 1, 2, 0, 0, 160, 32, 24, 126, 32, 24, 0, 0u } },
	{ { 2, 11, 0, 0, 2, 6, 1, 0, 9, 0, 0, 208, 138, 16, 62, 224, 45, 0, 0u } },
	{ { 17, 11, 0, 0, 2, 5, 2, 0, 5, 0, 0, 208, 144, 12, 64, 64, 49, 0, 0u } },
	{ { 19, 4, 0, 96, 5, 5, 2, 2, 5, 1, 0, 0, 188, 184, 40, 208, 30, 1, 1u } },
	{ { 4, 4, 0, 96, 5, 5, 2, 1, 5, 0, 0, 0, 114, 110, 40, 208, 30, 1, 1u } },
	{ { 20, 4, 0, 97, 7, 5, 4, 2, 2, 2, 0, 128, 208, 16, 44, 56, 22, 1, 1u } },
	{ { 5, 4, 0, 97, 7, 5, 4, 1, 2, 0, 0, 128, 24, 88, 44, 56, 22, 1, 1u } },
	{ { 31, 2, 0, 96, 7, 5, 4, 2, 4, 2, 0, 128, 208, 16, 44, 56, 45, 1, 1u } },
	{ { 16, 2, 0, 96, 7, 5, 4, 1, 4, 0, 0, 128, 24, 88, 44, 56, 45, 1, 1u } },
	{ { 32, 4, 0, 96, 7, 5, 4, 3, 4, 2, 0, 128, 62, 126, 44, 56, 45, 1, 1u } },
	{ { 33, 4, 0, 0, 7, 5, 4, 2, 4, 2, 0, 128, 208, 16, 44, 56, 45, 1, 1u } },
	{ { 34, 4, 0, 0, 7, 5, 4, 1, 4, 0, 0, 128, 24, 88, 44, 56, 45, 1, 1u } },
	{ { 160, 2, 0, 96, 7, 5, 8, 3, 4, 2, 0, 128, 62, 126, 44, 157, 45, 1, 1u } },
	{ { 147, 2, 0, 96, 5, 5, 5, 2, 5, 1, 0, 0, 188, 184, 40, 190, 30, 1, 1u } },
	{ { 132, 2, 0, 96, 5, 5, 5, 1, 5, 0, 0, 0, 114, 110, 40, 160, 30, 1, 1u } },
	{ { 257, 1, 0, 96, 15, 10, 8, 2, 8, 0, 0, 0, 48, 176, 88, 112, 90, 1, 1u } },
	{ { 258, 1, 0, 96, 15, 10, 8, 5, 8, 4, 0, 0, 160, 32, 88, 112, 90, 1, 1u } },
	{ { 259, 1, 0, 96, 15, 10, 8, 6, 8, 4, 0, 0, 124, 252, 88, 112, 90, 1, 1u } },
	{ { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0u } },
}; // idb

static uintptr_t hdmi_base_addr; // idb
//static struct hdmi_bsp_func hdmi_func; // idb
static unsigned int tmp_rcal_100; // idb
static unsigned int tmp_rcal_200; // idb
static unsigned int rcal_flag; // idb
static unsigned int bias_source; // idb
static unsigned int hdmi_version; // idb
static const uint8_t ca_table [64] =
{ 0, 17, 1, 19, 2, 49, 3, 51, 4, 21, 5, 23, 6, 53, 7, 55, 8, 85, 9, 87, 10, 117, 11, 119, 12, 93, 13, 95, 14, 125, 15, 127, 16, 221, 17, 223, 18, 253, 19, 255, 20, 153, 21, 155, 22, 185, 23, 187, 24, 157,
		25, 159, 26, 189, 27, 191, 28, 221, 29, 223, 30, 253, 31, 255u }; // idb
static const struct pcm_sf sf [10] =
{
{ 22050, 4u },
{ 44100, 0u },
{ 88200, 8u },
{ 176400, 12u },
{ 24000, 6u },
{ 48000, 2u },
{ 96000, 10u },
{ 192000, 14u },
{ 32000, 3u },
{ 768000, 9u } }; // idb

static const unsigned int n_table [21] =
{ 32000, 3072, 4096, 44100, 4704, 6272, 88200, 9408, 12544, 176400, 18816, 25088, 48000, 5120, 6144, 96000, 10240, 12288, 192000, 20480, 24576u }; // idb

//----- (0000000000000000) ----------------------------------------------------
static void hdmi_write(unsigned addr, uint8_t data)
{
	__DSB();
	* (volatile uint8_t*) (addr + hdmi_base_addr) = data;
}

//----- (0000000000000020) ----------------------------------------------------
static void hdmi_writel(unsigned addr, unsigned int data)
{
	__DSB();
	* (volatile uint32_t*) (addr + hdmi_base_addr) = data;
}

//----- (0000000000000040) ----------------------------------------------------
static unsigned int get_vid(unsigned int vic)
{
	int64_t v2; // x1
	unsigned int result; // w0

	v2 = 0;
	while (1)
	{
		result = v2;
		if (vic == ptbl [v2].para [0])
			break;
		if (++ v2 == 19)
		{
			ptbl [19].para [0] = vic;
			return 19;
		}
	}
	return result;
}

//----- (0000000000000088) ----------------------------------------------------
static void hdmi_udelay(uint64_t us)
{
	local_delay_us(us);
}

//----- (00000000000000D8) ----------------------------------------------------
static void hdmi_mdelay(uint64_t ms)
{
	local_delay_ms(ms);
}

//----- (0000000000000128) ----------------------------------------------------
static void hdmi_phy_init(void)
{
	uintptr_t v1; // x20
	uintptr_t v2; // x20
	int v3; // w1
	int v4; // w20
	uintptr_t v5; // x20
	uintptr_t v6; // x20
	uint64_t v7; // x21
	int v8; // w1

	hdmi_writel(0x10020, 0);
	hdmi_writel(0x10020, 1);
	hdmi_udelay(5);
	v1 = hdmi_base_addr + 0x10000;
	hdmi_writel(0x10020, * (volatile uint32_t*) (hdmi_base_addr + 65568) | 0x10000);
	hdmi_writel(0x10020, * (volatile uint32_t*) (v1 + 32) | 2);
	hdmi_udelay(0xA);
	hdmi_writel(0x10020, * (volatile uint32_t*) (hdmi_base_addr + 65568) | 4);
	hdmi_udelay(5);
	hdmi_writel(0x10020, * (volatile uint32_t*) (hdmi_base_addr + 65568) | 8);
	hdmi_udelay(0x28);
	hdmi_writel(0x10020, * (volatile uint32_t*) (hdmi_base_addr + 65568) | 0x80000);
	hdmi_udelay(0x64);
	v2 = hdmi_base_addr + 0x10000;
	hdmi_writel(0x10020, * (volatile uint32_t*) (hdmi_base_addr + 65568) | 0x40000);
	v3 = * (volatile uint32_t*) (v2 + 32);
	v4 = 10;
	hdmi_writel(0x10020, v3 | 0x70);
	do
	{
		if ((* (volatile uint32_t*) (hdmi_base_addr + 65592) & 0x80) != 0)
			break;
		hdmi_udelay(0xC8);
		-- v4;
	} while (v4);
	PRINTF("PLL status=%02X\n", * (volatile uint32_t*) (hdmi_base_addr + 65592));
	v5 = hdmi_base_addr + 0x10000;
	hdmi_writel(0x10020, * (volatile uint32_t*) (hdmi_base_addr + 65568) | 0xF00);
	hdmi_writel(0x10020, * (volatile uint32_t*) (v5 + 32) | 0x80);
	hdmi_writel(0x1002C, 0x39DC5040);
	hdmi_writel(0x10030, 0x80084343);
	hdmi_mdelay(0xA);
	hdmi_writel(0x10034, 1);
	hdmi_writel(0x1002C, * (volatile uint32_t*) (hdmi_base_addr + 65580) | 0x2000000);
	hdmi_mdelay(100);

	v6 = hdmi_base_addr + 0x10000;
	v7 = * (volatile uint32_t*) (hdmi_base_addr + 65592);
	tmp_rcal_100 = (* (volatile uint32_t*) (hdmi_base_addr + 65592) & 0x3F) >> 1;
	tmp_rcal_200 = (uint8_t) (v7 & 0x3F) >> 2;
	v8 = * (volatile uint32_t*) (hdmi_base_addr + 65580);
	rcal_flag = 1;
	hdmi_writel(0x1002C, v8 | 0xC0000000);
	hdmi_writel(0x1002C, ((v7 >> 11) & 0x3F) | (* (volatile uint32_t*) (v6 + 44)));
	hdmi_writel(0x10020, 0x1FF0F7F);
	hdmi_writel(0x10024, 0x80639000);
	hdmi_writel(0x10028, 0xF81C405);
	if (bias_source)
		hdmi_writel(0x10004, * (volatile uint32_t*) (hdmi_base_addr + 0x10004) | 0x20000);
}
// 18: using guessed type int64_t *off_18;

//----- (00000000000003C0) ----------------------------------------------------
static int64_t hdmi_read(unsigned addr)
{
	return * (volatile uint8_t*) (hdmi_base_addr + addr);
}

//----- (00000000000003D8) ----------------------------------------------------
static void bsp_hdmi_inner_init(void)
{
	uint64_t v0; // x0

	hdmi_read(0);
	hdmi_write(0x10010, 0x45);
	hdmi_write(0x10011, 0x45);
	hdmi_write(0x10012, 0x52);
	hdmi_write(0x10013, 0x54);
	hdmi_write(0x8080, 0);
	hdmi_udelay(1);
	hdmi_write(0xF01F, 0);
	hdmi_write(0x8403, 0xFF);
	hdmi_write(0x904C, 0xFF);
	hdmi_write(0x904E, 0xFF);
	hdmi_write(0xD04C, 0xFF);
	hdmi_write(0x8250, 0xFF);
	hdmi_write(0x8A50, 0xFF);
	hdmi_write(0x8272, 0xFF);
	hdmi_write(0x40C0, 0xFF);
	hdmi_write(0x86F0, 0xFF);
	hdmi_write(0x0EE3, 0xFF);
	hdmi_write(0x8EE2, 0xFF);
	hdmi_write(0xA049, 0xF0);
	hdmi_write(0xB045, 0x1E);
	hdmi_write(0x00C1, 0);
	hdmi_write(0x00C1, 3);
	hdmi_write(0x00C0, 0);
	hdmi_write(0x40C1, 0x10);
	hdmi_write(0x0081, 0xFD);
	hdmi_write(0x0081, 0);
	hdmi_write(0x0081, 0xDD);
	hdmi_write(0x0010, 0xFF);
	hdmi_write(0x0011, 0xFF);
	hdmi_write(0x8010, 0xFF);
	hdmi_write(0x8011, 0xFF);
	hdmi_write(0x13, 0xFF);
	hdmi_write(0x8012, 0xFF);
	hdmi_write(0x8013, 0xFF);
}
// 3E0: variable 'v0' is possibly undefined

#if 0
//----- (0000000000000590) ----------------------------------------------------
static int bsp_hdmi_set_func(struct hdmi_bsp_func *func)
{
	void (*delay_us)(uint64_t); // x3
	void (*delay_ms)(uint64_t); // x0

	hdmi_func.delay_us = 0;
	hdmi_func.delay_ms = 0;
	if (func)
	{
		delay_us = func->delay_us;
		delay_ms = func->delay_ms;
		hdmi_func.delay_us = delay_us;
		hdmi_func.delay_ms = delay_ms;
	}
	return 0;
}
#endif

//----- (00000000000005C0) ----------------------------------------------------
int bsp_hdmi_set_bias_source(unsigned int src)
{
	bias_source = src;
	return 0;
}

//----- (00000000000005D8) ----------------------------------------------------
void bsp_hdmi_set_version(unsigned int version)
{
	hdmi_version = version;
}

//----- (00000000000005F0) ----------------------------------------------------
void bsp_hdmi_set_addr(uintptr_t base_addr)
{
	hdmi_base_addr = base_addr;
	rcal_flag = 0;
}

//----- (0000000000000608) ----------------------------------------------------
static void bsp_hdmi_init(void)
{
	hdmi_phy_init();
	bsp_hdmi_inner_init();
}
// 610: variable 'v0' is possibly undefined

//----- (0000000000000620) ----------------------------------------------------
static void bsp_hdmi_set_video_en(uint8_t enable)
{
	unsigned int v1; // w1

	if (enable)
		v1 = * (volatile uint32_t*) (hdmi_base_addr + 65568) | 0xF000;
	else
		v1 = * (volatile uint32_t*) (hdmi_base_addr + 65568) & 0xFFFF0FFF;
	hdmi_writel(0x10020, v1);
}

//----- (0000000000000678) ----------------------------------------------------
static int bsp_hdmi_video_get_div(unsigned int pixel_clk)
{
	int result; // w0

	result = 1;
	if (pixel_clk <= 0x8D9EE20)
	{
		result = 2;
		if (pixel_clk <= 0x46CF710)
		{
			if (pixel_clk <= 0x19BFCC0)
				return 11;
			else
				return 4;
		}
	}
	return result;
}

static unsigned video_csc;
static unsigned video_is_yuv;
static unsigned video_is_hcts;
static unsigned video_is_hdmi = 1;
static unsigned video_clk_div = 1;

//----- (00000000000006C0) ----------------------------------------------------
static int bsp_hdmi_video(unsigned vic)
{
	int64_t vid; // x25
	unsigned int v3; // w0
	enum color_space v4; // w0
	unsigned int v5; // w0
	int64_t v6; // x23
	unsigned int clk_div; // w22
	int v8; // w22
	unsigned int v9; // w1
	uintptr_t v10; // x22
	uint64_t v11; // x23
	int64_t v12; // x0
	int v13; // w1
	int v14; // w1
	int v15; // w1
	uintptr_t v16; // x22
	uint64_t v17; // x23
	uint16_t v18; // w1
	uintptr_t v19; // x22
	uint64_t v20; // x23
	uintptr_t v21; // x22
	uint64_t v22; // x23
	struct para_tab *v23; // x22
	unsigned int v24; // w23
	uint8_t v25; // w1
	unsigned int v26; // w22
	uint8_t v27; // w1
	unsigned int v28; // w22
	uint8_t v29; // w1
	int v30; // w24
	uint8_t v31; // w1
//	uint64_t v32; // x0
//	uint64_t v33; // x0
	uint8_t v34; // w1
	enum color_space csc; // w1
	unsigned int v36; // w0
	uint8_t v37; // w1
	uint8_t v38; // w22
	uint8_t v39; // w1
	uint8_t v40; // w1
	uint8_t v41; // w1
	uint8_t v42; // w1
	uint64_t v43; // x0
	uint8_t v44; // w1
	uint64_t v45; // x0
	int result; // w0

	vid = get_vid(vic);
	v3 = vic - 2;
	if ( v3 <= 0x13 && ((1LL << v3) & 0x88011) != 0 )
		video_csc = /* color_space:: */BT601;
	else
		video_csc = /* color_space:: */BT709;
#if 0
	if ((uint32_t) vid == 19)
	{
		ptbl [19].para [1] = bsp_hdmi_video_get_div(video_pixel_clk);
		ptbl [19].para [2] = video_pixel_repeat;
		ptbl [19].para [3] = (32 * (video_hor_sync_polarity & 1)) | ((video_ver_sync_polarity & 1) << 6) | video_b_interlace & 1;
		ptbl [19].para [4] = video_x_res >> 8;
		ptbl [19].para [5] = video_ver_sync_time;
		ptbl [19].para [6] = video_y_res >> 8;
		ptbl [19].para [7] = (video_hor_total_time - video_x_res) >> 8;
		ptbl [19].para [8] = video_ver_front_porch;
		ptbl [19].para [9] = video_hor_front_porch >> 8;
		ptbl [19].para [10] = video_hor_sync_time >> 8;
		ptbl [19].para [11] = LOBYTE(video_x_res);
		ptbl [19].para [12] = (uint8_t) (LOBYTE(video_hor_total_time) - LOBYTE(video_x_res));
		ptbl [19].para [13] = LOBYTE(video_hor_front_porch);
		ptbl [19].para [14] = LOBYTE(video_hor_sync_time);
		ptbl [19].para [15] = LOBYTE(video_y_res);
		ptbl [19].para [16] = video_ver_total_time - video_y_res;
		v4 = /* color_space:: */BT601;
		ptbl [19].para [17] = 1;
		ptbl [19].para [18] = 1;
		if ( video_x_res > 0x2E0 || video_y_res > 0x240 )
			v4 = /* color_space:: */BT709;
		video_csc = v4;
	}
#endif

	if (! rcal_flag)
		hdmi_phy_init();
	v5 = get_vid(vic);
	v6 = v5;
	if (v5 == 19)
		clk_div = video_clk_div;
	else
		clk_div = ptbl [v5].para [1];
	v8 = (clk_div - 1) & 0xF;
	hdmi_writel(0x10020, * (volatile uint32_t*) (hdmi_base_addr + 0x10020) & 0xFFFF0FFF);
	switch (ptbl [v6].para [1])
	{
	case 1u:
		if (hdmi_version)
			v9 = 819748800;
		else
			v9 = 836526016;
		hdmi_writel(0x1002C, v9);
		hdmi_writel(0x10030, v8 | 0x800863C0);
		hdmi_mdelay(0xA);
		hdmi_writel(0x10034, 1);
		hdmi_writel(0x1002C, * (volatile uint32_t*) (hdmi_base_addr + 65580) | 0x2000000);
		hdmi_mdelay(0xC8);
		v10 = hdmi_base_addr + 0x10000;
		v11 = * (volatile uint32_t*) (hdmi_base_addr + 65592);
		hdmi_writel(0x1002C, * (volatile uint32_t*) (hdmi_base_addr + 65580) | 0xC0000000);
		v12 = (v11 >> 11) & 0x3F;
		v13 = * (volatile uint32_t*) (v10 + 44);
		if ((unsigned int) v12 > 0x3C)
			v14 = v13 | 0x3F;
		else
			v14 = (v12 + 2) | v13;
		hdmi_writel(0x1002C, v14);
		hdmi_mdelay(0x64);
		hdmi_writel(0x10020, 0x1FFFF7F);
		hdmi_writel(0x10024, 0x8063B000);
		v15 = 260196021;
		goto LABEL_27;
	case 2u:
		hdmi_writel(0x1002C, 0x39DC5040);
		hdmi_writel(0x10030, v8 | 0x80084380);
		hdmi_mdelay(0xA);
		hdmi_writel(0x10034, 1);
		hdmi_writel(0x1002C, * (volatile uint32_t*) (hdmi_base_addr + 65580) | 0x2000000);
		hdmi_mdelay(0x64);
		v16 = hdmi_base_addr + 0x10000;
		v17 = ((uint64_t) * (volatile uint32_t*) (hdmi_base_addr + 65592) >> 11) & 0x3F;
		hdmi_writel(0x1002C, * (volatile uint32_t*) (hdmi_base_addr + 65580) | 0xC0000000);
		hdmi_writel(0x1002C, v17 | * (volatile uint32_t*) (v16 + 44));
		hdmi_writel(0x10020, 0x1FFFF7F);
		hdmi_writel(0x10024, 0x8063A800);
		v18 = - 15227;
		goto LABEL_25;
	case 4u:
		hdmi_writel(0x1002C, 0x39DC5040);
		hdmi_writel(0x10030, v8 | 0x80084340);
		hdmi_mdelay(0xA);
		hdmi_writel(0x10034, 1);
		hdmi_writel(0x1002C, * (volatile uint32_t*) (hdmi_base_addr + 65580) | 0x2000000);
		hdmi_mdelay(0x64);
		v19 = hdmi_base_addr + 0x10000;
		v20 = ((uint64_t) * (volatile uint32_t*) (hdmi_base_addr + 65592) >> 11) & 0x3F;
		hdmi_writel(0x1002C, * (volatile uint32_t*) (hdmi_base_addr + 65580) | 0xC0000000);
		hdmi_writel(0x1002C, v20 | * (volatile uint32_t*) (v19 + 44));
		hdmi_writel(0x10020, 0x11FFFF7F);
		hdmi_writel(0x10024, tmp_rcal_200 | 0x80623000);
		v18 = 17285;
		LABEL_25: v15 = v18 | 0xF810000;
		goto LABEL_27;
	case 0xBu:
		hdmi_writel(0x1002C, 0x39DC5040);
		hdmi_writel(0x10030, v8 | 0x80084300);
		hdmi_mdelay(0xA);
		hdmi_writel(0x10034, 1);
		hdmi_writel(0x1002C, * (volatile uint32_t*) (hdmi_base_addr + 65580) | 0x2000000);
		hdmi_mdelay(0x64);
		v21 = hdmi_base_addr + 0x10000;
		v22 = ((uint64_t) * (volatile uint32_t*) (hdmi_base_addr + 65592) >> 11) & 0x3F;
		hdmi_writel(0x1002C, * (volatile uint32_t*) (hdmi_base_addr + 65580) | 0xC0000000);
		hdmi_writel(0x1002C, v22 | * (volatile uint32_t*) (v21 + 44));
		hdmi_writel(0x10020, 0x11FFFF7F);
		hdmi_writel(0x10024, tmp_rcal_200 | 0x80623000);
		v15 = 260096645;
		LABEL_27: hdmi_writel(0x10028, v15);
		bsp_hdmi_inner_init();
		hdmi_write(0x840, 1);
		hdmi_write(0x4845, 0);
		v23 = & ptbl [(unsigned int) vid];
		v24 = v23->para [3];
		hdmi_write(0x40, v24 | 0x10);
		if (v24 >= 0x60)
			v25 = 0;
		else
			v25 = 3;
		hdmi_write(0x10001, v25);
		hdmi_write(0x8040, v23->para [4]);
		hdmi_write(0x4043, v23->para [5]);
		hdmi_write(0x8042, v23->para [6]);
		hdmi_write(0x42, v23->para [7]);
		hdmi_write(0x4042, v23->para [8]);
		hdmi_write(0x4041, v23->para [9]);
		hdmi_write(0xC041, v23->para [10]);
		hdmi_write(0x41, v23->para [11]);
		hdmi_write(0x8041, v23->para [12]);
		hdmi_write(0x4040, v23->para [13]);
		hdmi_write(0xC040, v23->para [14]);
		hdmi_write(0x43, v23->para [15]);
		hdmi_write(0x8043, v23->para [16]);
		hdmi_write(0x45, 0xC);
		hdmi_write(0x8044, 0x20);
		hdmi_write(0x8045, 1);
		hdmi_write(0x46, 0xB);
		hdmi_write(0x47, 0x16);
		hdmi_write(0x8046, 0x21);
		v26 = v23->para [2];
		if (v26)
			v27 = 33;
		else
			v27 = 16;
		hdmi_write(0x3048, v27);
		hdmi_write(0x401, v26 != 0);
		hdmi_write(0x8400, 7);
		hdmi_write(0x8401, 0);
		hdmi_write(0x402, 0x47);
		hdmi_write(0x800, 1);
		hdmi_write(0x801, 7);
		hdmi_write(0x8800, 0);
		hdmi_write(0x8801, 0);
		hdmi_write(0x802, 0);
		hdmi_write(0x803, 0);
		hdmi_write(0x8802, 0);
		hdmi_write(0x8803, 0);
		if (video_is_hdmi)
		{
			hdmi_write(0xB045, 8);
			hdmi_write(0x2045, 0);
			hdmi_write(0x2044, 0xC);
			hdmi_write(0x6041, 3);
			v28 = ptbl [(unsigned int) vid].para [0];
			v29 = 32;
			v30 = v28 & 0x100;
			if ((v28 & 0x100) == 0)
			{
				if ((v28 & 0x80) != 0)
					v29 = 64;
				else
					v29 = 0;
			}
			hdmi_write(0xA044, v29);
			v31 = v28 & 0x7F;
			if ((v28 & 0x100) == 0)
				v31 = 0;
			hdmi_write(0xA045, v31);
			hdmi_write(0x2046, 0);
			hdmi_write(0x3046, 1);
			hdmi_write(0x3047, 0x11);
			hdmi_write(0x4044, 0);
			hdmi_write(0x0052, 0);
			hdmi_write(0x8051, 0x11);

			hdmi_read(0);
			hdmi_write(0x10010, 0x45);
			hdmi_write(0x10011, 0x45);
			hdmi_write(0x10012, 0x52);
			hdmi_write(0x10013, 0x54);
			hdmi_write(0x40, * (volatile uint8_t*) (hdmi_base_addr + 0x40) | 8);
			hdmi_read(0);
			hdmi_write(0x10010, 0x52);
			hdmi_write(0x10011, 0x54);
			hdmi_write(0x10012, 0x41);
			hdmi_write(0x10013, 0x57);
			if (video_is_yuv)
				v34 = 2;
			else
				v34 = 0;
			hdmi_write(0x4045, v34);
			csc = video_csc;
			v36 = ptbl [vid].para [17];
			if (v36)
			{
				if (v36 == 1)
					v37 = ((uint8_t) csc << 6) | 0x28;
				else
					v37 = ((uint8_t) csc << 6) | 8;
			}
			else
			{
				v37 = ((uint8_t) csc << 6) | 0x18;
			}
			v38 = v28 & 0x7F;
			hdmi_write(0xC044, v37);
			if (video_is_yuv)
				v39 = 0;
			else
				v39 = 4;
			hdmi_write(0xC045, v39);
			if (v30)
				v40 = 0;
			else
				v40 = v38;
			hdmi_write(0x4046, v40);
		}
		if (video_is_hcts)
		{
			if (video_is_hdmi)
				v41 = - 111;
			else
				v41 = - 112;
			hdmi_write(0xC0, v41);
			hdmi_write(0xC1, 5);
			if (v24 >= 0x60)
				v42 = 26;
			else
				v42 = 16;
			hdmi_write(0x40C1, v42);
			hdmi_write(0x80C2, 0xFF);
			hdmi_write(0x40C0, 0xFD);
			hdmi_write(0xC0C0, 0x40);
			hdmi_write(0xC1, 4);
			hdmi_read(v43);
			hdmi_write(0x10010, 0x45);
			hdmi_write(0x10011, 0x45);
			hdmi_write(0x10012, 0x52);
			hdmi_write(0x10013, 0x54);
			hdmi_write(0x40, * (volatile uint8_t*) (hdmi_base_addr + 64) | 0x80);
			if (video_is_hdmi)
				v44 = - 107;
			else
				v44 = - 108;
			hdmi_write(0xC0, v44);
			hdmi_read(v45);
			hdmi_write(0x10010, 0x52);
			hdmi_write(0x10011, 0x54);
			hdmi_write(0x10012, 0x41);
			hdmi_write(0x10013, 0x57);
		}
		hdmi_write(0x82, 0);
		hdmi_write(0x81, 0);
		hdmi_write(0x840, 0);
		result = 0;
		break;
	default:
		result = - 1;
		break;
	}
	return result;
}
// EE8: variable 'v32' is possibly undefined
// F44: variable 'v33' is possibly undefined
// 108C: variable 'v43' is possibly undefined
// 1100: variable 'v45' is possibly undefined
// 18: using guessed type int64_t *off_18;

#if 0
//----- (00000000000011A8) ----------------------------------------------------
static int bsp_hdmi_audio(unsigned vic)
{
	unsigned int vid; // w21
	uint8_t v3; // w1
	int64_t v4; // x0
	int64_t v5; // x0
	unsigned int sample_bit; // w0
	uint8_t v7; // w1
	const unsigned int *v8; // x0
	int v9; // w1
	int v10; // w1
	unsigned int v11; // w20
	unsigned int v12; // w1
	uint64_t v13; // x0
	uint8_t v14; // w1

	vid = get_vid(audio_vic);
	if (audio_ch_num <= 2)
		v3 = - 16;
	else
		v3 = - 15;
	hdmi_write(0xA049, v3);
	v4 = 0;
	while (ca_table [v4] != audio_ca)
	{
		v4 += 2;
		if (v4 == 64)
			goto LABEL_8;
	}
	hdmi_write(0x204B, ~ ca_table [(unsigned int) (v4 + 1)]);
	LABEL_8: hdmi_write(0xA04A, 0);
	hdmi_write(0xA04B, 0x30);
	hdmi_write(0x6048, 0);
	hdmi_write(0x6049, 1);
	hdmi_write(0xE048, 0x42);
	hdmi_write(0xE049, 0x86);
	hdmi_write(0x604A, 0x31);
	hdmi_write(0x604B, 0x75);
	hdmi_write(0xE04A, 1);
	v5 = 0;
	while (audio_sample_rate != sf [v5].sf)
	{
		if (++ v5 == 10)
			goto LABEL_12;
	}
	hdmi_write(0xE04A, sf [(unsigned int) v5].cs_sf);
	LABEL_12: sample_bit = audio_sample_bit;
	v7 = 2;
	if (sample_bit != 16)
	{
		if (sample_bit == 24)
			v7 = 11;
		else
			v7 = 0;
	}
	hdmi_write(0xE04B, v7);
	hdmi_write(0x0251, audio_sample_bit);
	v8 = n_table;
	v9 = 0;
	while (audio_sample_rate != * v8)
	{
		v9 += 3;
		v8 += 3;
		if (v9 == 21)
		{
			v11 = 6272;
			goto LABEL_25;
		}
	}
	if (vid == 19 || ptbl [vid].para [1] != 1)
		v10 = v9 + 2;
	else
		v10 = v9 + 1;
	v11 = n_table [v10];

	LABEL_25:
	hdmi_write(0x0A40, v11);
	hdmi_write(0x0A41, BYTE1(v11));
	hdmi_write(0x8A40, BYTE2(v11));
	hdmi_write(0x0A43, 0);
	hdmi_write(0x8A42, 4);
	hdmi_write(0xA049, audio_ch_num > 2);
	v12 &= ~ 0xFFu;
	if ( audio_type == PCM)
		v12 = 16 * (audio_ch_num + 0xFFFFFFF);
	hdmi_write(0x2043, v12);
	//hdmi_write(0x2043, audio_ch_num * 16);

	hdmi_write(0xA042, 0);
	hdmi_write(0xA043, audio_ca);
	hdmi_write(0x6040, 0);
	if ( audio_type == PCM)
	{
		v13 = 33361LL;
	}
	else
	{
		v14 = 3;
		if ((unsigned int) (audio_type - 11) > 1)
			v14 = 2;
		hdmi_write(0x8251, v14);
		hdmi_write(0x251, 0x15);
		v13 = 41027LL;
	}
	hdmi_write(v13, 0);
	hdmi_write(0x250, 0);
	hdmi_write(0x81, 8);
	hdmi_write(0x8080, 0xF7);
	hdmi_udelay(0x64);
	hdmi_write(0x250, 0xAF);
	hdmi_udelay(0x64);
	hdmi_write(0x81, 0);
	return 0;
}
#endif

#if 0
//----- (00000000000014C0) ----------------------------------------------------
// local variable allocation has failed, the output may be wrong!
static int bsp_hdmi_ddc_read(char cmd, char pointer, char offset, int nbyte, char *pbuf)
{
	int v9; // w20
	int v10; // w23
	char v11; // w21
	uint64_t v12; // x0
	int v13; // w20
	volatile uint8_t *v14; // x1

	hdmi_read(0);
	v9 = 50;
	hdmi_write(0x10010, 0x45);
	hdmi_write(0x10011, 0x45);
	hdmi_write(0x10012, 0x52);
	hdmi_write(0x10013, 0x54);
	hdmi_write(0x4EE1, 0);
	do
	{
		if ((* (volatile uint8_t*) (hdmi_base_addr + 20193) & 1) != 0)
			break;
		hdmi_udelay(10);
		-- v9;
	} while (v9);
	v10 = 0;
	v11 = offset + nbyte;
	hdmi_write(0x8EE3, 5);
	hdmi_write(0xEE3, 8);
	hdmi_write(0x4EE2, 0xD8);
	hdmi_write(0xCEE2, 0xFE);
	while (nbyte > 0)
	{
		hdmi_write(0xEE0, 0x50);
		v13 = 10;
		hdmi_write(0xEE1, v11 - nbyte);
		hdmi_write(0x4EE0, 0x30);
		hdmi_write(0xCEE0, pointer);
		hdmi_write(0xEE2, 2);
		while (-- v13)
		{
			v14 = (volatile uint8_t*) (hdmi_base_addr + 19);
			if ((* (volatile uint8_t*) (hdmi_base_addr + 19) & 2) != 0)
			{
				++ pbuf;
				hdmi_write(0x13, * v14 & 2);
				v12 = * (volatile uint8_t*) (hdmi_base_addr + 36577);
				* (pbuf - 1) = v12;
				break;
			}
			if ((* (volatile uint8_t*) (hdmi_base_addr + 19) & 1) != 0)
			{
				v10 = - 1;
				hdmi_write(0x13, * v14 & 1);
				break;
			}
			hdmi_udelay(0x3E8);
		}
		-- nbyte;
	}
	hdmi_read(0);
	hdmi_write(0x10010, 0x52);
	hdmi_write(0x10011, 0x54);
	hdmi_write(0x10012, 0x41);
	hdmi_write(0x10013, 0x57);
	return v10;
}
// 14C0: variables would overlap: w0.1 and x0.8
#endif

#if 0
//----- (00000000000016C8) ----------------------------------------------------
static unsigned int bsp_hdmi_get_hpd(void)
{
	uint64_t v0; // x0
	uint64_t v1;// x23

	hdmi_read(0);
	hdmi_write(0x10010, 0x45);
	hdmi_write(0x10011, 0x45);
	hdmi_write(0x10012, 0x52);
	hdmi_write(0x10013, 0x54);
	v1 = *(volatile uint32_t*)(hdmi_base_addr + 65592);
	hdmi_read(0);
	hdmi_write(0x10010, 0x52);
	hdmi_write(0x10011, 0x54);
	hdmi_write(0x10012, 0x41);
	hdmi_write(0x10013, 0x57);
	return (v1 >> 19) & 1;
}
// 16E4: variable 'v0' is possibly undefined
#endif

//----- (0000000000001798) ----------------------------------------------------
static void bsp_hdmi_standby(void)
{
	hdmi_write(0x10020, 7);
	hdmi_write(0x1002C, 0);
}

//----- (00000000000017C8) ----------------------------------------------------
static void bsp_hdmi_hrst(void)
{
	hdmi_write(0xC1, 4);
	hdmi_write(0x81, 0x40);
}

#if 0

//----- (00000000000017F4) ----------------------------------------------------
static int bsp_hdmi_hdcp_err_check(void)
{
	int v1;// w19

	v1 = 0;
	hdmi_read(0);
	hdmi_write(0x10010, 0x45);
	hdmi_write(0x10011, 0x45);
	hdmi_write(0x10012, 0x52);
	hdmi_write(0x10013, 0x54);
	v2 = *(uint8_t *)(hdmi_base_addr + 32960) & 0xFE;
	if ( (uint32_t)v2 != 64 )
	{
		v1 = -1;
		hdmi_write(0xC1, *(uint8_t *)(hdmi_base_addr + 193) & 0xFE);
	}
	hdmi_read(0);
	hdmi_write(0x10010, 0x52);
	hdmi_write(0x10011, 0x54);
	hdmi_write(0x10012, 0x41);
	hdmi_write(0x10013, 0x57);
	return v1;
}
// 1804: variable 'v0' is possibly undefined
// 1878: variable 'v2' is possibly undefined
#endif

#if 0
//----- (00000000000018D8) ----------------------------------------------------
static int bsp_hdmi_cec_get_simple_msg(uint8_t *msg)
{
	int v2; // w19
	uintptr_t v4; // x0

	v2 = - 1;
	hdmi_write(0x1003C, 4);
	hdmi_write(0x10010, 0x45);
	hdmi_write(0x10011, 0x45);
	hdmi_write(0x10012, 0x52);
	hdmi_write(0x10013, 0x54);
	hdmi_write(0x6F3, 0xFF);
	hdmi_write(0x86F2, 0xFF);
	hdmi_read(0);
	v4 = hdmi_base_addr + 0x2000;
	if ((* (volatile uint8_t*) (hdmi_base_addr + 9972) & 1) != 0)
	{
		* msg = * (volatile uint8_t*) (hdmi_base_addr + 9969);
		v2 = 0;
		hdmi_write(0x26F4, 0);
	}
	hdmi_read(0);
	hdmi_write(0x10010, 0x52);
	hdmi_write(0x10011, 0x54);
	hdmi_write(0x10012, 0x41);
	hdmi_write(0x10013, 0x57);
	return v2;
}
// 1954: variable 'v3' is possibly undefined
// 1984: variable 'v4' is possibly undefined

//----- (00000000000019E0) ----------------------------------------------------
static int bsp_hdmi_cec_send(char *buf, uint8_t bytes)
{
	int result; // w0
	unsigned int v5; // w19
	int64_t v6; // x19
	uint64_t v7; // x0
	uint8_t v8; // w1
	int64_t v9; // x20
	uint64_t v10; // x0
	uint64_t v11; // x0
	uint64_t v12; // x0
	int64_t v13; // x1
	uint64_t v14; // x0
	uint64_t v15; // x0
	uint64_t v16; // x0
	uint64_t v17; // x0

	result = - 1;
	v5 = (uint8_t) (bytes - 1);
	if (v5 <= 0xF)
	{
		hdmi_read(0);
		v6 = (uint8_t) v5 + 32017LL;
		hdmi_write(0x10010, 0x45);
		hdmi_write(0x10011, 0x45);
		hdmi_write(0x10012, 0x52);
		hdmi_write(0x10013, 0x54);
		hdmi_read(0);
		v8 = bytes;
		v9 = 32016LL;
		hdmi_write(0x86F3, v8);
		hdmi_read(0);
		hdmi_writel(0x10014, 0x42494E47);
		hdmi_read(0);
		do
		{
			v12 = v9;
			v13 = v9 - 32016;
			++ v9;
			hdmi_write(v12, buf [v13]);
		} while (v9 != v6);
		hdmi_read(0);
		hdmi_writel(0x10014, 0);
		hdmi_read(0);
		hdmi_udelay(0x14);
		hdmi_write(0x6F0, * (volatile uint8_t*) (hdmi_base_addr + 1776) | 1);
		hdmi_read(0);
		hdmi_write(0x10010, 0x52);
		hdmi_write(0x10011, 0x54);
		hdmi_write(0x10012, 0x41);
		hdmi_write(0x10013, 0x57);
		hdmi_read(0);
		return 0;
	}
	return result;
}
// 1A5C: variable 'v7' is possibly undefined
// 1A70: variable 'v10' is possibly undefined
// 1A88: variable 'v11' is possibly undefined
// 1AAC: variable 'v14' is possibly undefined
// 1AC0: variable 'v15' is possibly undefined
// 1AE8: variable 'v16' is possibly undefined
// 1B2C: variable 'v17' is possibly undefined

//----- (0000000000001B50) ----------------------------------------------------
// local variable allocation has failed, the output may be wrong!
static void bsp_hdmi_cec_free_time_set(uint8_t value)
{
	hdmi_read(0);
	hdmi_write(0x10010, 0x45);
	hdmi_write(0x10011, 0x45);
	hdmi_write(0x10012, 0x52);
	hdmi_write(0x10013, 0x54);
	hdmi_read(0);
	hdmi_write(0x6F0, (* (volatile uint8_t*) (hdmi_base_addr + 1776) & 0xF9) | (2 * value));
	hdmi_read(0);
	hdmi_write(0x10010, 0x52);
	hdmi_write(0x10011, 0x54);
	hdmi_write(0x10012, 0x41);
	hdmi_write(0x10013, 0x57);
	hdmi_read(0);
}
// 1B50: variables would overlap: w0.1 and x0.8

//----- (0000000000001C38) ----------------------------------------------------
static int bsp_hdmi_cec_sta_check(void)
{
	char v0; // w19

	hdmi_write(0x10010, 0x45);
	hdmi_write(0x10011, 0x45);
	hdmi_write(0x10012, 0x52);
	hdmi_write(0x10013, 0x54);
	v0 = *(uint8_t *)(hdmi_base_addr + 32786);
	hdmi_write(0x10010, 0x52);
	hdmi_write(0x10011, 0x54);
	hdmi_write(0x10012, 0x41);
	hdmi_write(0x10013, 0x57);
	return -!(v0 & 1);
}
#endif

// nfuncs=27 queued=26 decompiled=26 lumina nreq=0 worse=0 better=0
//

void t507_hdmi_phy_init(uint_fast32_t dotclock)
{
	unsigned int vic = 16;
	bsp_hdmi_init();
	bsp_hdmi_video(vic);
}

#endif
