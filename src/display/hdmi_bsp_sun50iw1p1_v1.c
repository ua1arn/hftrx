// https://dogbolt.org/

#include "hardware.h"
#include "formats.h"	// for PRINTF prints

#if WITHLTDCHW && WITHHDMITVHW && 1

/* This file was generated by the Hex-Rays decompiler version 8.4.0.240320.
 Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

 Detected compiler: GNU C++
 */
struct video_para;
struct audio_para;
struct hdmi_bsp_func;


enum audio_type
{
	PCM = 1,
	AC3,
	MPEG1,
	MP3,
	MPEG2,
	AAC,
	DTS,
	ATRAC,
	OBA,
	DDP,
	DTS_HD,
	MAT,
	DST,
	WMA_PRO,
};

static unsigned audio_vic;
static unsigned audio_ca;	// ????????
static unsigned audio_ch_num = 2;
static unsigned audio_sample_rate = 48000;
static unsigned audio_sample_bit = 24;
static unsigned audio_type = PCM;

//-------------------------------------------------------------------------
// Function declarations

static void hdmi_write(uint64_t addr, uint8_t data);
static void hdmi_writel(uint64_t addr, unsigned int data);
static unsigned int get_vid(unsigned int id);
static void hdmi_udelay(uint64_t us);
static void hdmi_mdelay(uint64_t ms);
static void hdmi_phy_init(struct video_para *video); // idb
static int64_t hdmi_read(uint64_t addr);
static void bsp_hdmi_inner_init(void);
static int bsp_hdmi_set_func(struct hdmi_bsp_func *func);
static  bsp_hdmi_set_bias_source(unsigned int src);
static void bsp_hdmi_set_version(unsigned int version);
static void bsp_hdmi_set_addr(uint64_t base_addr);
static void bsp_hdmi_init(void);
static void bsp_hdmi_set_video_en(uint8_t enable);
static int bsp_hdmi_video_get_div(unsigned int pixel_clk);
static int bsp_hdmi_video(struct video_para *video);
static int bsp_hdmi_audio(struct audio_para *audio);
static int bsp_hdmi_ddc_read(char cmd, char pointer, char offset, int nbyte, char *pbuf);
static unsigned int bsp_hdmi_get_hpd(void);
static void bsp_hdmi_standby(void);
static void bsp_hdmi_hrst(void);
static int bsp_hdmi_hdcp_err_check(void);
static int bsp_hdmi_cec_get_simple_msg(uint8_t *msg);
static int bsp_hdmi_cec_send(char *buf, uint8_t bytes);
static void bsp_hdmi_cec_free_time_set(uint8_t value);
static int bsp_hdmi_cec_sta_check(void);


enum color_space {
	BT601 = 1,
	BT709,
	EXT_CSC,
};

struct para_tab
{
	unsigned int para[19];
};

struct pcm_sf
{
	unsigned int 	sf;
	unsigned char	cs_sf;
};

//-------------------------------------------------------------------------
// Data declarations

static struct para_tab ptbl [20] =
{
{
{ 6u, 1u, 1u, 1u, 5u, 3u, 0u, 1u, 4u, 0u, 0u, 160u, 20u, 38u, 124u, 240u, 22u, 0u, 0u } },
{
{ 21u, 11u, 1u, 1u, 5u, 3u, 1u, 1u, 2u, 0u, 0u, 160u, 32u, 24u, 126u, 32u, 24u, 0u, 0u } },
{
{ 2u, 11u, 0u, 0u, 2u, 6u, 1u, 0u, 9u, 0u, 0u, 208u, 138u, 16u, 62u, 224u, 45u, 0u, 0u } },
{
{ 17u, 11u, 0u, 0u, 2u, 5u, 2u, 0u, 5u, 0u, 0u, 208u, 144u, 12u, 64u, 64u, 49u, 0u, 0u } },
{
{ 19u, 4u, 0u, 96u, 5u, 5u, 2u, 2u, 5u, 1u, 0u, 0u, 188u, 184u, 40u, 208u, 30u, 1u, 1u } },
{
{ 4u, 4u, 0u, 96u, 5u, 5u, 2u, 1u, 5u, 0u, 0u, 0u, 114u, 110u, 40u, 208u, 30u, 1u, 1u } },
{
{ 20u, 4u, 0u, 97u, 7u, 5u, 4u, 2u, 2u, 2u, 0u, 128u, 208u, 16u, 44u, 56u, 22u, 1u, 1u } },
{
{ 5u, 4u, 0u, 97u, 7u, 5u, 4u, 1u, 2u, 0u, 0u, 128u, 24u, 88u, 44u, 56u, 22u, 1u, 1u } },
{
{ 31u, 2u, 0u, 96u, 7u, 5u, 4u, 2u, 4u, 2u, 0u, 128u, 208u, 16u, 44u, 56u, 45u, 1u, 1u } },
{
{ 16u, 2u, 0u, 96u, 7u, 5u, 4u, 1u, 4u, 0u, 0u, 128u, 24u, 88u, 44u, 56u, 45u, 1u, 1u } },
{
{ 32u, 4u, 0u, 96u, 7u, 5u, 4u, 3u, 4u, 2u, 0u, 128u, 62u, 126u, 44u, 56u, 45u, 1u, 1u } },
{
{ 33u, 4u, 0u, 0u, 7u, 5u, 4u, 2u, 4u, 2u, 0u, 128u, 208u, 16u, 44u, 56u, 45u, 1u, 1u } },
{
{ 34u, 4u, 0u, 0u, 7u, 5u, 4u, 1u, 4u, 0u, 0u, 128u, 24u, 88u, 44u, 56u, 45u, 1u, 1u } },
{
{ 160u, 2u, 0u, 96u, 7u, 5u, 8u, 3u, 4u, 2u, 0u, 128u, 62u, 126u, 44u, 157u, 45u, 1u, 1u } },
{
{ 147u, 2u, 0u, 96u, 5u, 5u, 5u, 2u, 5u, 1u, 0u, 0u, 188u, 184u, 40u, 190u, 30u, 1u, 1u } },
{
{ 132u, 2u, 0u, 96u, 5u, 5u, 5u, 1u, 5u, 0u, 0u, 0u, 114u, 110u, 40u, 160u, 30u, 1u, 1u } },
{
{ 257u, 1u, 0u, 96u, 15u, 10u, 8u, 2u, 8u, 0u, 0u, 0u, 48u, 176u, 88u, 112u, 90u, 1u, 1u } },
{
{ 258u, 1u, 0u, 96u, 15u, 10u, 8u, 5u, 8u, 4u, 0u, 0u, 160u, 32u, 88u, 112u, 90u, 1u, 1u } },
{
{ 259u, 1u, 0u, 96u, 15u, 10u, 8u, 6u, 8u, 4u, 0u, 0u, 124u, 252u, 88u, 112u, 90u, 1u, 1u } },
{
{ 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u } } }; // idb
static uintptr_t hdmi_base_addr; // idb
//static struct hdmi_bsp_func hdmi_func; // idb
static unsigned int tmp_rcal_100; // idb
static unsigned int tmp_rcal_200; // idb
static unsigned int rcal_flag; // idb
static unsigned int bias_source; // idb
static unsigned int hdmi_version; // idb
static const uint8_t ca_table [64] =
{ 0u, 17u, 1u, 19u, 2u, 49u, 3u, 51u, 4u, 21u, 5u, 23u, 6u, 53u, 7u, 55u, 8u, 85u, 9u, 87u, 10u, 117u, 11u, 119u, 12u, 93u, 13u, 95u, 14u, 125u, 15u, 127u, 16u, 221u, 17u, 223u, 18u, 253u, 19u, 255u, 20u, 153u, 21u, 155u, 22u, 185u, 23u, 187u, 24u, 157u,
		25u, 159u, 26u, 189u, 27u, 191u, 28u, 221u, 29u, 223u, 30u, 253u, 31u, 255u }; // idb
static const struct pcm_sf sf [10] =
{
{ 22050u, 4u },
{ 44100u, 0u },
{ 88200u, 8u },
{ 176400u, 12u },
{ 24000u, 6u },
{ 48000u, 2u },
{ 96000u, 10u },
{ 192000u, 14u },
{ 32000u, 3u },
{ 768000u, 9u } }; // idb

static const unsigned int n_table [21] =
{ 32000u, 3072u, 4096u, 44100u, 4704u, 6272u, 88200u, 9408u, 12544u, 176400u, 18816u, 25088u, 48000u, 5120u, 6144u, 96000u, 10240u, 12288u, 192000u, 20480u, 24576u }; // idb

//----- (0000000000000000) ----------------------------------------------------
static void hdmi_write(uint64_t addr, uint8_t data)
{
	__dsb(0xEu);
	* (volatile uint8_t*) (addr + hdmi_base_addr) = data;
}

//----- (0000000000000020) ----------------------------------------------------
static void hdmi_writel(uint64_t addr, unsigned int data)
{
	__dsb(0xEu);
	* (volatile uint32_t*) (addr + hdmi_base_addr) = data;
}

//----- (0000000000000040) ----------------------------------------------------
unsigned int get_vid(unsigned int id)
{
	int64_t v2; // x1
	unsigned int result; // w0

	v2 = 0LL;
	while (1)
	{
		result = v2;
		if (id == ptbl [v2].para [0])
			break;
		if (++ v2 == 19)
		{
			ptbl [19].para [0] = id;
			return 19;
		}
	}
	return result;
}

//----- (0000000000000088) ----------------------------------------------------
void hdmi_udelay(uint64_t us)
{
	uint64_t v1; // x1
	int v2; // w0

	v1 = us;
	if (hdmi_func.delay_us)
	{
		hdmi_func.delay_us(us);
	}
	else
	{
		while (-- v1 != - 1LL)
		{
			v2 = 11;
			do
				-- v2;
			while (v2);
		}
	}
}

//----- (00000000000000D8) ----------------------------------------------------
void hdmi_mdelay(uint64_t ms)
{
	uint64_t v1; // x1
	int v2; // w0

	v1 = ms;
	if (hdmi_func.delay_ms)
	{
		hdmi_func.delay_ms(ms);
	}
	else
	{
		while (-- v1 != - 1LL)
		{
			v2 = 10001;
			do
				-- v2;
			while (v2);
		}
	}
}

//----- (0000000000000128) ----------------------------------------------------
void hdmi_phy_init(struct video_para *video)
{
	uint64_t v1; // x20
	uint64_t v2; // x20
	int v3; // w1
	int v4; // w20
	uint64_t v5; // x20
	uintptr_t v6; // x20
	uint64_t v7; // x21
	int v8; // w1

	hdmi_writel(0x10020u, 0);
	hdmi_writel(0x10020u, 1u);
	hdmi_udelay(5u);
	v1 = hdmi_base_addr + 0x10000;
	hdmi_writel(0x10020u, * (volatile uint32_t*) (hdmi_base_addr + 65568) | 0x10000);
	hdmi_writel(0x10020u, * (volatile uint32_t*) (v1 + 32) | 2);
	hdmi_udelay(0xAu);
	hdmi_writel(0x10020u, * (volatile uint32_t*) (hdmi_base_addr + 65568) | 4);
	hdmi_udelay(5u);
	hdmi_writel(0x10020u, * (volatile uint32_t*) (hdmi_base_addr + 65568) | 8);
	hdmi_udelay(0x28u);
	hdmi_writel(0x10020u, * (volatile uint32_t*) (hdmi_base_addr + 65568) | 0x80000);
	hdmi_udelay(0x64u);
	v2 = hdmi_base_addr + 0x10000;
	hdmi_writel(0x10020u, * (volatile uint32_t*) (hdmi_base_addr + 65568) | 0x40000);
	v3 = * (volatile uint32_t*) (v2 + 32);
	v4 = 10;
	hdmi_writel(0x10020u, v3 | 0x70);
	do
	{
		if ((* (volatile uint32_t*) (hdmi_base_addr + 65592) & 0x80) != 0)
			break;
		hdmi_udelay(0xC8u);
		-- v4;
	} while (v4);
	v5 = hdmi_base_addr + 0x10000;
	hdmi_writel(0x10020u, * (volatile uint32_t*) (hdmi_base_addr + 65568) | 0xF00);
	hdmi_writel(0x10020u, * (volatile uint32_t*) (v5 + 32) | 0x80);
	hdmi_writel(0x1002Cu, 0x39DC5040u);
	hdmi_writel(0x10030u, 0x80084343);
	hdmi_mdelay(0xAu);
	hdmi_writel(0x10034u, 1u);
	hdmi_writel(0x1002Cu, * (volatile uint32_t*) (hdmi_base_addr + 65580) | 0x2000000);
	hdmi_mdelay(0x64u);
	v6 = hdmi_base_addr + 0x10000;
	v7 = * (volatile uint32_t*) (hdmi_base_addr + 65592);
	tmp_rcal_100 = (* (volatile uint32_t*) (hdmi_base_addr + 65592) & 0x3Fu) >> 1;
	tmp_rcal_200 = (uint8_t) (v7 & 0x3F) >> 2;
	v8 = * (volatile uint32_t*) (hdmi_base_addr + 65580);
	rcal_flag = 1;
	hdmi_writel(0x1002Cu, v8 | 0xC0000000);
	hdmi_writel(0x1002Cu, (v7 >> 11) & 0x3F | * (volatile uint32_t*) (v6 + 44));
	hdmi_writel(0x10020u, 0x1FF0F7Fu);
	hdmi_writel(0x10024u, 0x80639000);
	hdmi_writel(0x10028u, 0xF81C405u);
	if (bias_source)
		hdmi_writel(0x10004u, * (volatile uint32_t*) (v6 + 4) | 0x20000);
}
// 18: using guessed type int64_t *off_18;

//----- (00000000000003C0) ----------------------------------------------------
int64_t hdmi_read(uint64_t addr)
{
	return * (volatile uint8_t*) hdmi_base_addr;
}

//----- (00000000000003D8) ----------------------------------------------------
void bsp_hdmi_inner_init(void)
{
	uint64_t v0; // x0

	hdmi_read(v0);
	hdmi_write(0x10010u, 0x45u);
	hdmi_write(0x10011u, 0x45u);
	hdmi_write(0x10012u, 0x52u);
	hdmi_write(0x10013u, 0x54u);
	hdmi_write(0x8080u, 0);
	hdmi_udelay(1u);
	hdmi_write(0xF01Fu, 0);
	hdmi_write(0x8403u, 0xFFu);
	hdmi_write(0x904Cu, 0xFFu);
	hdmi_write(0x904Eu, 0xFFu);
	hdmi_write(0xD04Cu, 0xFFu);
	hdmi_write(0x8250u, 0xFFu);
	hdmi_write(0x8A50u, 0xFFu);
	hdmi_write(0x8272u, 0xFFu);
	hdmi_write(0x40C0u, 0xFFu);
	hdmi_write(0x86F0u, 0xFFu);
	hdmi_write(0xEE3u, 0xFFu);
	hdmi_write(0x8EE2u, 0xFFu);
	hdmi_write(0xA049u, 0xF0u);
	hdmi_write(0xB045u, 0x1Eu);
	hdmi_write(0xC1u, 0);
	hdmi_write(0xC1u, 3u);
	hdmi_write(0xC0u, 0);
	hdmi_write(0x40C1u, 0x10u);
	hdmi_write(0x81u, 0xFDu);
	hdmi_write(0x81u, 0);
	hdmi_write(0x81u, 0xDDu);
	hdmi_write(0x10u, 0xFFu);
	hdmi_write(0x11u, 0xFFu);
	hdmi_write(0x8010u, 0xFFu);
	hdmi_write(0x8011u, 0xFFu);
	hdmi_write(0x13u, 0xFFu);
	hdmi_write(0x8012u, 0xFFu);
	hdmi_write(0x8013u, 0xFFu);
}
// 3E0: variable 'v0' is possibly undefined

//----- (0000000000000590) ----------------------------------------------------
int bsp_hdmi_set_func(struct hdmi_bsp_func *func)
{
	void (*delay_us)(uint64_t); // x3
	void (*delay_ms)(uint64_t); // x0

	hdmi_func.delay_us = 0LL;
	hdmi_func.delay_ms = 0LL;
	if (func)
	{
		delay_us = func->delay_us;
		delay_ms = func->delay_ms;
		hdmi_func.delay_us = delay_us;
		hdmi_func.delay_ms = delay_ms;
	}
	return 0;
}

//----- (00000000000005C0) ----------------------------------------------------
int bsp_hdmi_set_bias_source(unsigned int src)
{
	bias_source = src;
	return 0;
}

//----- (00000000000005D8) ----------------------------------------------------
void bsp_hdmi_set_version(unsigned int version)
{
	hdmi_version = version;
}

//----- (00000000000005F0) ----------------------------------------------------
void bsp_hdmi_set_addr(uint64_t base_addr)
{
	hdmi_base_addr = base_addr;
	rcal_flag = 0;
}

//----- (0000000000000608) ----------------------------------------------------
void bsp_hdmi_init(void)
{
	struct video_para *v0; // x0

	hdmi_phy_init(v0);
	bsp_hdmi_inner_init();
}
// 610: variable 'v0' is possibly undefined

//----- (0000000000000620) ----------------------------------------------------
void bsp_hdmi_set_video_en(uint8_t enable)
{
	unsigned int v1; // w1

	if (enable)
		v1 = * (volatile uint32_t*) (hdmi_base_addr + 65568) | 0xF000;
	else
		v1 = * (volatile uint32_t*) (hdmi_base_addr + 65568) & 0xFFFF0FFF;
	hdmi_writel(0x10020u, v1);
}

//----- (0000000000000678) ----------------------------------------------------
int bsp_hdmi_video_get_div(unsigned int pixel_clk)
{
	int result; // w0

	result = 1;
	if (pixel_clk <= 0x8D9EE20)
	{
		result = 2;
		if (pixel_clk <= 0x46CF710)
		{
			if (pixel_clk <= 0x19BFCC0)
				return 11;
			else
				return 4;
		}
	}
	return result;
}

static unsigned video_csc;
static unsigned video_is_yuv;
static unsigned video_is_hcts;
static unsigned video_is_hdmi = 1;

//----- (00000000000006C0) ----------------------------------------------------
int bsp_hdmi_video(struct video_para *video)
{
	int64_t vid; // x25
	unsigned int v3; // w0
	enum color_space v4; // w0
	unsigned int v5; // w0
	int64_t v6; // x23
	unsigned int clk_div; // w22
	int v8; // w22
	unsigned int v9; // w1
	uint64_t v10; // x22
	uint64_t v11; // x23
	int64_t v12; // x0
	int v13; // w1
	int v14; // w1
	int v15; // w1
	uint64_t v16; // x22
	uint64_t v17; // x23
	uint16_t
	v18; // w1
	uint64_t v19; // x22
	uint64_t v20; // x23
	uint64_t v21; // x22
	uint64_t v22; // x23
	struct para_tab *v23; // x22
	unsigned int v24; // w23
	uint8_t v25; // w1
	unsigned int v26; // w22
	uint8_t v27; // w1
	unsigned int v28; // w22
	uint8_t v29; // w1
	int v30; // w24
	uint8_t v31; // w1
	uint64_t v32; // x0
	uint64_t v33; // x0
	uint8_t v34; // w1
	enum color_space csc; // w1
	unsigned int v36; // w0
	uint8_t v37; // w1
	uint8_t v38; // w22
	uint8_t v39; // w1
	uint8_t v40; // w1
	uint8_t v41; // w1
	uint8_t v42; // w1
	uint64_t v43; // x0
	uint8_t v44; // w1
	uint64_t v45; // x0
	int result; // w0

	vid = get_vid(video_vic);
	v3 = video_vic - 2;
	if ( v3 <= 0x13 && ((1LL << v3) & 0x88011) != 0 )
		video_csc = /* color_space:: */BT601;
	else
		video_csc = /* color_space:: */BT709;
	if ((uint32_t) vid == 19)
	{
		ptbl [19].para [1] = bsp_hdmi_video_get_div(video_pixel_clk);
		ptbl [19].para [2] = video_pixel_repeat;
		ptbl [19].para [3] = (32 * (video_hor_sync_polarity & 1)) | ((video_ver_sync_polarity & 1) << 6) | video_b_interlace & 1;
		ptbl [19].para [4] = video_x_res >> 8;
		ptbl [19].para [5] = video_ver_sync_time;
		ptbl [19].para [6] = video_y_res >> 8;
		ptbl [19].para [7] = (video_hor_total_time - video_x_res) >> 8;
		ptbl [19].para [8] = video_ver_front_porch;
		ptbl [19].para [9] = video_hor_front_porch >> 8;
		ptbl [19].para [10] = video_hor_sync_time >> 8;
		ptbl [19].para [11] = LOBYTE(video_x_res);
		ptbl [19].para [12] = (uint8_t) (LOBYTE(video_hor_total_time) - LOBYTE(video_x_res));
		ptbl [19].para [13] = LOBYTE(video_hor_front_porch);
		ptbl [19].para [14] = LOBYTE(video_hor_sync_time);
		ptbl [19].para [15] = LOBYTE(video_y_res);
		ptbl [19].para [16] = video_ver_total_time - video_y_res;
		v4 = /* color_space:: */BT601;
		ptbl [19].para [17] = 1;
		ptbl [19].para [18] = 1;
		if ( video_x_res > 0x2E0 || video_y_res > 0x240 )
		v4 = /* color_space:: */BT709;
		video_csc = v4;
	}
	if (! rcal_flag)
		hdmi_phy_init(0LL);
	v5 = get_vid(video_vic);
	v6 = v5;
	if (v5 == 19)
		clk_div = video_clk_div;
	else
		clk_div = ptbl [v5].para [1];
	v8 = (clk_div - 1) & 0xF;
	hdmi_writel(0x10020u, * (volatile uint32_t*) (hdmi_base_addr + 65568) & 0xFFFF0FFF);
	switch (ptbl [v6].para [1])
	{
	case 1u:
		if (hdmi_version)
			v9 = 819748800;
		else
			v9 = 836526016;
		hdmi_writel(0x1002Cu, v9);
		hdmi_writel(0x10030u, v8 | 0x800863C0);
		hdmi_mdelay(0xAu);
		hdmi_writel(0x10034u, 1u);
		hdmi_writel(0x1002Cu, * (volatile uint32_t*) (hdmi_base_addr + 65580) | 0x2000000);
		hdmi_mdelay(0xC8u);
		v10 = hdmi_base_addr + 0x10000;
		v11 = * (volatile uint32_t*) (hdmi_base_addr + 65592);
		hdmi_writel(0x1002Cu, * (volatile uint32_t*) (hdmi_base_addr + 65580) | 0xC0000000);
		v12 = (v11 >> 11) & 0x3F;
		v13 = * (volatile uint32_t*) (v10 + 44);
		if ((unsigned int) v12 > 0x3C)
			v14 = v13 | 0x3F;
		else
			v14 = (v12 + 2) | v13;
		hdmi_writel(0x1002Cu, v14);
		hdmi_mdelay(0x64u);
		hdmi_writel(0x10020u, 0x1FFFF7Fu);
		hdmi_writel(0x10024u, 0x8063B000);
		v15 = 260196021;
		goto LABEL_27;
	case 2u:
		hdmi_writel(0x1002Cu, 0x39DC5040u);
		hdmi_writel(0x10030u, v8 | 0x80084380);
		hdmi_mdelay(0xAu);
		hdmi_writel(0x10034u, 1u);
		hdmi_writel(0x1002Cu, * (volatile uint32_t*) (hdmi_base_addr + 65580) | 0x2000000);
		hdmi_mdelay(0x64u);
		v16 = hdmi_base_addr + 0x10000;
		v17 = ((uint64_t) * (volatile uint32_t*) (hdmi_base_addr + 65592) >> 11) & 0x3F;
		hdmi_writel(0x1002Cu, * (volatile uint32_t*) (hdmi_base_addr + 65580) | 0xC0000000);
		hdmi_writel(0x1002Cu, v17 | * (volatile uint32_t*) (v16 + 44));
		hdmi_writel(0x10020u, 0x1FFFF7Fu);
		hdmi_writel(0x10024u, 0x8063A800);
		v18 = - 15227;
		goto LABEL_25;
	case 4u:
		hdmi_writel(0x1002Cu, 0x39DC5040u);
		hdmi_writel(0x10030u, v8 | 0x80084340);
		hdmi_mdelay(0xAu);
		hdmi_writel(0x10034u, 1u);
		hdmi_writel(0x1002Cu, * (volatile uint32_t*) (hdmi_base_addr + 65580) | 0x2000000);
		hdmi_mdelay(0x64u);
		v19 = hdmi_base_addr + 0x10000;
		v20 = ((uint64_t) * (volatile uint32_t*) (hdmi_base_addr + 65592) >> 11) & 0x3F;
		hdmi_writel(0x1002Cu, * (volatile uint32_t*) (hdmi_base_addr + 65580) | 0xC0000000);
		hdmi_writel(0x1002Cu, v20 | * (volatile uint32_t*) (v19 + 44));
		hdmi_writel(0x10020u, 0x11FFFF7Fu);
		hdmi_writel(0x10024u, tmp_rcal_200 | 0x80623000);
		v18 = 17285;
		LABEL_25: v15 = v18 | 0xF810000;
		goto LABEL_27;
	case 0xBu:
		hdmi_writel(0x1002Cu, 0x39DC5040u);
		hdmi_writel(0x10030u, v8 | 0x80084300);
		hdmi_mdelay(0xAu);
		hdmi_writel(0x10034u, 1u);
		hdmi_writel(0x1002Cu, * (volatile uint32_t*) (hdmi_base_addr + 65580) | 0x2000000);
		hdmi_mdelay(0x64u);
		v21 = hdmi_base_addr + 0x10000;
		v22 = ((uint64_t) * (volatile uint32_t*) (hdmi_base_addr + 65592) >> 11) & 0x3F;
		hdmi_writel(0x1002Cu, * (volatile uint32_t*) (hdmi_base_addr + 65580) | 0xC0000000);
		hdmi_writel(0x1002Cu, v22 | * (volatile uint32_t*) (v21 + 44));
		hdmi_writel(0x10020u, 0x11FFFF7Fu);
		hdmi_writel(0x10024u, tmp_rcal_200 | 0x80623000);
		v15 = 260096645;
		LABEL_27: hdmi_writel(0x10028u, v15);
		bsp_hdmi_inner_init();
		hdmi_write(0x840u, 1u);
		hdmi_write(0x4845u, 0);
		v23 = & ptbl [(unsigned int) vid];
		v24 = v23->para [3];
		hdmi_write(0x40u, v24 | 0x10);
		if (v24 >= 0x60)
			v25 = 0;
		else
			v25 = 3;
		hdmi_write(0x10001u, v25);
		hdmi_write(0x8040u, v23->para [4]);
		hdmi_write(0x4043u, v23->para [5]);
		hdmi_write(0x8042u, v23->para [6]);
		hdmi_write(0x42u, v23->para [7]);
		hdmi_write(0x4042u, v23->para [8]);
		hdmi_write(0x4041u, v23->para [9]);
		hdmi_write(0xC041u, v23->para [10]);
		hdmi_write(0x41u, v23->para [11]);
		hdmi_write(0x8041u, v23->para [12]);
		hdmi_write(0x4040u, v23->para [13]);
		hdmi_write(0xC040u, v23->para [14]);
		hdmi_write(0x43u, v23->para [15]);
		hdmi_write(0x8043u, v23->para [16]);
		hdmi_write(0x45u, 0xCu);
		hdmi_write(0x8044u, 0x20u);
		hdmi_write(0x8045u, 1u);
		hdmi_write(0x46u, 0xBu);
		hdmi_write(0x47u, 0x16u);
		hdmi_write(0x8046u, 0x21u);
		v26 = v23->para [2];
		if (v26)
			v27 = 33;
		else
			v27 = 16;
		hdmi_write(0x3048u, v27);
		hdmi_write(0x401u, v26 != 0);
		hdmi_write(0x8400u, 7u);
		hdmi_write(0x8401u, 0);
		hdmi_write(0x402u, 0x47u);
		hdmi_write(0x800u, 1u);
		hdmi_write(0x801u, 7u);
		hdmi_write(0x8800u, 0);
		hdmi_write(0x8801u, 0);
		hdmi_write(0x802u, 0);
		hdmi_write(0x803u, 0);
		hdmi_write(0x8802u, 0);
		hdmi_write(0x8803u, 0);
		if (video_is_hdmi)
		{
			hdmi_write(0xB045u, 8u);
			hdmi_write(0x2045u, 0);
			hdmi_write(0x2044u, 0xCu);
			hdmi_write(0x6041u, 3u);
			v28 = ptbl [(unsigned int) vid].para [0];
			v29 = 32;
			v30 = v28 & 0x100;
			if ((v28 & 0x100) == 0)
			{
				if ((v28 & 0x80) != 0)
					v29 = 64;
				else
					v29 = 0;
			}
			hdmi_write(0xA044u, v29);
			v31 = v28 & 0x7F;
			if ((v28 & 0x100) == 0)
				v31 = 0;
			hdmi_write(0xA045u, v31);
			hdmi_write(0x2046u, 0);
			hdmi_write(0x3046u, 1u);
			hdmi_write(0x3047u, 0x11u);
			hdmi_write(0x4044u, 0);
			hdmi_write(0x52u, 0);
			hdmi_write(0x8051u, 0x11u);
			hdmi_read(v32);
			hdmi_write(0x10010u, 0x45u);
			hdmi_write(0x10011u, 0x45u);
			hdmi_write(0x10012u, 0x52u);
			hdmi_write(0x10013u, 0x54u);
			hdmi_write(0x40u, * (volatile uint8_t*) (hdmi_base_addr + 64) | 8);
			hdmi_read(v33);
			hdmi_write(0x10010u, 0x52u);
			hdmi_write(0x10011u, 0x54u);
			hdmi_write(0x10012u, 0x41u);
			hdmi_write(0x10013u, 0x57u);
			if (video_is_yuv)
				v34 = 2;
			else
				v34 = 0;
			hdmi_write(0x4045u, v34);
			csc = video_csc;
			v36 = ptbl [vid].para [17];
			if (v36)
			{
				if (v36 == 1)
					v37 = ((uint8_t) csc << 6) | 0x28;
				else
					v37 = ((uint8_t) csc << 6) | 8;
			}
			else
			{
				v37 = ((uint8_t) csc << 6) | 0x18;
			}
			v38 = v28 & 0x7F;
			hdmi_write(0xC044u, v37);
			if (video_is_yuv)
				v39 = 0;
			else
				v39 = 4;
			hdmi_write(0xC045u, v39);
			if (v30)
				v40 = 0;
			else
				v40 = v38;
			hdmi_write(0x4046u, v40);
		}
		if (video_is_hcts)
		{
			if (video_is_hdmi)
				v41 = - 111;
			else
				v41 = - 112;
			hdmi_write(0xC0u, v41);
			hdmi_write(0xC1u, 5u);
			if (v24 >= 0x60)
				v42 = 26;
			else
				v42 = 16;
			hdmi_write(0x40C1u, v42);
			hdmi_write(0x80C2u, 0xFFu);
			hdmi_write(0x40C0u, 0xFDu);
			hdmi_write(0xC0C0u, 0x40u);
			hdmi_write(0xC1u, 4u);
			hdmi_read(v43);
			hdmi_write(0x10010u, 0x45u);
			hdmi_write(0x10011u, 0x45u);
			hdmi_write(0x10012u, 0x52u);
			hdmi_write(0x10013u, 0x54u);
			hdmi_write(0x40u, * (volatile uint8_t*) (hdmi_base_addr + 64) | 0x80);
			if (video_is_hdmi)
				v44 = - 107;
			else
				v44 = - 108;
			hdmi_write(0xC0u, v44);
			hdmi_read(v45);
			hdmi_write(0x10010u, 0x52u);
			hdmi_write(0x10011u, 0x54u);
			hdmi_write(0x10012u, 0x41u);
			hdmi_write(0x10013u, 0x57u);
		}
		hdmi_write(0x82u, 0);
		hdmi_write(0x81u, 0);
		hdmi_write(0x840u, 0);
		result = 0;
		break;
	default:
		result = - 1;
		break;
	}
	return result;
}
// EE8: variable 'v32' is possibly undefined
// F44: variable 'v33' is possibly undefined
// 108C: variable 'v43' is possibly undefined
// 1100: variable 'v45' is possibly undefined
// 18: using guessed type int64_t *off_18;

//----- (00000000000011A8) ----------------------------------------------------
int bsp_hdmi_audio(struct audio_para *audio)
{
	unsigned int vid; // w21
	uint8_t v3; // w1
	int64_t v4; // x0
	int64_t v5; // x0
	unsigned int sample_bit; // w0
	uint8_t v7; // w1
	const unsigned int *v8; // x0
	int v9; // w1
	int v10; // w1
	unsigned int v11; // w20
	unsigned int v12; // w1
	uint64_t v13; // x0
	uint8_t v14; // w1

	vid = get_vid(audio_vic);
	if (audio_ch_num <= 2)
		v3 = - 16;
	else
		v3 = - 15;
	hdmi_write(0xA049u, v3);
	v4 = 0LL;
	while (ca_table [v4] != audio_ca)
	{
		v4 += 2LL;
		if (v4 == 64)
			goto LABEL_8;
	}
	hdmi_write(0x204Bu, ~ ca_table [(unsigned int) (v4 + 1)]);
	LABEL_8: hdmi_write(0xA04Au, 0);
	hdmi_write(0xA04Bu, 0x30u);
	hdmi_write(0x6048u, 0);
	hdmi_write(0x6049u, 1u);
	hdmi_write(0xE048u, 0x42u);
	hdmi_write(0xE049u, 0x86u);
	hdmi_write(0x604Au, 0x31u);
	hdmi_write(0x604Bu, 0x75u);
	hdmi_write(0xE04Au, 1u);
	v5 = 0LL;
	while (audio_sample_rate != sf [v5].sf)
	{
		if (++ v5 == 10)
			goto LABEL_12;
	}
	hdmi_write(0xE04Au, sf [(unsigned int) v5].cs_sf);
	LABEL_12: sample_bit = audio_sample_bit;
	v7 = 2;
	if (sample_bit != 16)
	{
		if (sample_bit == 24)
			v7 = 11;
		else
			v7 = 0;
	}
	hdmi_write(0xE04Bu, v7);
	hdmi_write(0x251u, audio_sample_bit);
	v8 = n_table;
	v9 = 0;
	while (audio_sample_rate != * v8)
	{
		v9 += 3;
		v8 += 3;
		if (v9 == 21)
		{
			v11 = 6272;
			goto LABEL_25;
		}
	}
	if (vid == 19 || ptbl [vid].para [1] != 1)
		v10 = v9 + 2;
	else
		v10 = v9 + 1;
	v11 = n_table [v10];
	LABEL_25: hdmi_write(0xA40u, v11);
	hdmi_write(0xA41u, BYTE1(v11));
	hdmi_write(0x8A40u, BYTE2(v11));
	hdmi_write(0xA43u, 0);
	hdmi_write(0x8A42u, 4u);
	hdmi_write(0xA049u, audio_ch_num > 2);
	LOBYTE (v12) = 0;
	if ( audio_type == PCM)
		v12 = 16 * (audio_ch_num + 0xFFFFFFF);
	hdmi_write(0x2043u, v12);
	hdmi_write(0xA042u, 0);
	hdmi_write(0xA043u, audio_ca);
	hdmi_write(0x6040u, 0);
	if ( audio_type == PCM)
	{
		v13 = 33361LL;
	}
	else
	{
		v14 = 3;
		if ((unsigned int) (audio_type - 11) > 1)
			v14 = 2;
		hdmi_write(0x8251u, v14);
		hdmi_write(0x251u, 0x15u);
		v13 = 41027LL;
	}
	hdmi_write(v13, 0);
	hdmi_write(0x250u, 0);
	hdmi_write(0x81u, 8u);
	hdmi_write(0x8080u, 0xF7u);
	hdmi_udelay(0x64u);
	hdmi_write(0x250u, 0xAFu);
	hdmi_udelay(0x64u);
	hdmi_write(0x81u, 0);
	return 0;
}

//----- (00000000000014C0) ----------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int bsp_hdmi_ddc_read(char cmd, char pointer, char offset, int nbyte, char *pbuf)
{
	int v9; // w20
	int v10; // w23
	char v11; // w21
	uint64_t v12; // x0
	int v13; // w20
	uint8_t *v14; // x1

	hdmi_read(cmd);
	v9 = 50;
	hdmi_write(0x10010u, 0x45u);
	hdmi_write(0x10011u, 0x45u);
	hdmi_write(0x10012u, 0x52u);
	hdmi_write(0x10013u, 0x54u);
	hdmi_write(0x4EE1u, 0);
	do
	{
		if ((* (volatile uint8_t*) (hdmi_base_addr + 20193) & 1) != 0)
			break;
		hdmi_udelay(0xAu);
		-- v9;
	} while (v9);
	v10 = 0;
	v11 = offset + nbyte;
	hdmi_write(0x8EE3u, 5u);
	hdmi_write(0xEE3u, 8u);
	hdmi_write(0x4EE2u, 0xD8u);
	hdmi_write(0xCEE2u, 0xFEu);
	while (nbyte > 0)
	{
		hdmi_write(0xEE0u, 0x50u);
		v13 = 10;
		hdmi_write(0xEE1u, v11 - nbyte);
		hdmi_write(0x4EE0u, 0x30u);
		hdmi_write(0xCEE0u, pointer);
		hdmi_write(0xEE2u, 2u);
		while (-- v13)
		{
			v14 = (volatile uint8_t*) (hdmi_base_addr + 19);
			if ((* (volatile uint8_t*) (hdmi_base_addr + 19) & 2) != 0)
			{
				++ pbuf;
				hdmi_write(0x13u, * v14 & 2);
				v12 = * (volatile uint8_t*) (hdmi_base_addr + 36577);
				* (pbuf - 1) = v12;
				break;
			}
			if ((* (volatile uint8_t*) (hdmi_base_addr + 19) & 1) != 0)
			{
				v10 = - 1;
				hdmi_write(0x13u, * v14 & 1);
				break;
			}
			hdmi_udelay(0x3E8u);
		}
		-- nbyte;
	}
	hdmi_read(v12);
	hdmi_write(0x10010u, 0x52u);
	hdmi_write(0x10011u, 0x54u);
	hdmi_write(0x10012u, 0x41u);
	hdmi_write(0x10013u, 0x57u);
	return v10;
}
// 14C0: variables would overlap: w0.1 and x0.8

//----- (00000000000016C8) ----------------------------------------------------
unsigned int bsp_hdmi_get_hpd(void)
{
	uint64_t v0; // x0
	uint64_t v1;// x23

	hdmi_read(v0);
	hdmi_write(0x10010u, 0x45u);
	hdmi_write(0x10011u, 0x45u);
	hdmi_write(0x10012u, 0x52u);
	hdmi_write(0x10013u, 0x54u);
	v1 = *(volatile uint32_t*)(hdmi_base_addr + 65592);
	hdmi_read(hdmi_base_addr + 0x10000);
	hdmi_write(0x10010u, 0x52u);
	hdmi_write(0x10011u, 0x54u);
	hdmi_write(0x10012u, 0x41u);
	hdmi_write(0x10013u, 0x57u);
	return (v1 >> 19) & 1;
}
// 16E4: variable 'v0' is possibly undefined

//----- (0000000000001798) ----------------------------------------------------
void bsp_hdmi_standby(void)
{
	hdmi_write(0x10020u, 7u);
	hdmi_write(0x1002Cu, 0);
}

//----- (00000000000017C8) ----------------------------------------------------
void bsp_hdmi_hrst(void)
{
	hdmi_write(0xC1u, 4u);
	hdmi_write(0x81u, 0x40u);
}

//----- (00000000000017F4) ----------------------------------------------------
int bsp_hdmi_hdcp_err_check(void)
{
	uint64_t v0; // x0
	int v1;// w19
	uint64_t v2;// x0

	v1 = 0;
	hdmi_read(v0);
	hdmi_write(0x10010u, 0x45u);
	hdmi_write(0x10011u, 0x45u);
	hdmi_write(0x10012u, 0x52u);
	hdmi_write(0x10013u, 0x54u);
	v2 = *(uint8_t *)(hdmi_base_addr + 32960) & 0xFE;
	if ( (uint32_t)v2 != 64 )
	{
		v1 = -1;
		hdmi_write(0xC1u, *(uint8_t *)(hdmi_base_addr + 193) & 0xFE);
	}
	hdmi_read(v2);
	hdmi_write(0x10010u, 0x52u);
	hdmi_write(0x10011u, 0x54u);
	hdmi_write(0x10012u, 0x41u);
	hdmi_write(0x10013u, 0x57u);
	return v1;
}
// 1804: variable 'v0' is possibly undefined
// 1878: variable 'v2' is possibly undefined

//----- (00000000000018D8) ----------------------------------------------------
int bsp_hdmi_cec_get_simple_msg(uint8_t *msg)
{
	int v2; // w19
	uint64_t v3; // x0
	uint64_t v4; // x0

	v2 = - 1;
	hdmi_write(0x1003Cu, 4u);
	hdmi_write(0x10010u, 0x45u);
	hdmi_write(0x10011u, 0x45u);
	hdmi_write(0x10012u, 0x52u);
	hdmi_write(0x10013u, 0x54u);
	hdmi_write(0x6F3u, 0xFFu);
	hdmi_write(0x86F2u, 0xFFu);
	hdmi_read(v3);
	v4 = hdmi_base_addr + 0x2000;
	if ((* (volatile uint8_t*) (hdmi_base_addr + 9972) & 1) != 0)
	{
		* msg = * (volatile uint8_t*) (hdmi_base_addr + 9969);
		v2 = 0;
		hdmi_write(0x26F4u, 0);
	}
	hdmi_read(v4);
	hdmi_write(0x10010u, 0x52u);
	hdmi_write(0x10011u, 0x54u);
	hdmi_write(0x10012u, 0x41u);
	hdmi_write(0x10013u, 0x57u);
	return v2;
}
// 1954: variable 'v3' is possibly undefined
// 1984: variable 'v4' is possibly undefined

//----- (00000000000019E0) ----------------------------------------------------
int bsp_hdmi_cec_send(char *buf, uint8_t bytes)
{
	int result; // w0
	unsigned int v5; // w19
	int64_t v6; // x19
	uint64_t v7; // x0
	uint8_t v8; // w1
	int64_t v9; // x20
	uint64_t v10; // x0
	uint64_t v11; // x0
	uint64_t v12; // x0
	int64_t v13; // x1
	uint64_t v14; // x0
	uint64_t v15; // x0
	uint64_t v16; // x0
	uint64_t v17; // x0

	result = - 1;
	v5 = (uint8_t) (bytes - 1);
	if (v5 <= 0xF)
	{
		hdmi_read(0xFFFFFFFFu);
		v6 = (uint8_t) v5 + 32017LL;
		hdmi_write(0x10010u, 0x45u);
		hdmi_write(0x10011u, 0x45u);
		hdmi_write(0x10012u, 0x52u);
		hdmi_write(0x10013u, 0x54u);
		hdmi_read(v7);
		v8 = bytes;
		v9 = 32016LL;
		hdmi_write(0x86F3u, v8);
		hdmi_read(v10);
		hdmi_writel(0x10014u, 0x42494E47u);
		hdmi_read(v11);
		do
		{
			v12 = v9;
			v13 = v9 - 32016;
			++ v9;
			hdmi_write(v12, buf [v13]);
		} while (v9 != v6);
		hdmi_read(v14);
		hdmi_writel(0x10014u, 0);
		hdmi_read(v15);
		hdmi_udelay(0x14u);
		hdmi_write(0x6F0u, * (volatile uint8_t*) (hdmi_base_addr + 1776) | 1);
		hdmi_read(v16);
		hdmi_write(0x10010u, 0x52u);
		hdmi_write(0x10011u, 0x54u);
		hdmi_write(0x10012u, 0x41u);
		hdmi_write(0x10013u, 0x57u);
		hdmi_read(v17);
		return 0;
	}
	return result;
}
// 1A5C: variable 'v7' is possibly undefined
// 1A70: variable 'v10' is possibly undefined
// 1A88: variable 'v11' is possibly undefined
// 1AAC: variable 'v14' is possibly undefined
// 1AC0: variable 'v15' is possibly undefined
// 1AE8: variable 'v16' is possibly undefined
// 1B2C: variable 'v17' is possibly undefined

//----- (0000000000001B50) ----------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void bsp_hdmi_cec_free_time_set(uint8_t value)
{
	uint64_t v2; // x0
	uint64_t v3; // x0
	uint64_t v4; // x0

	hdmi_read(value);
	hdmi_write(0x10010u, 0x45u);
	hdmi_write(0x10011u, 0x45u);
	hdmi_write(0x10012u, 0x52u);
	hdmi_write(0x10013u, 0x54u);
	hdmi_read(v2);
	hdmi_write(0x6F0u, * (volatile uint8_t*) (hdmi_base_addr + 1776) & 0xF9 | (2 * value));
	hdmi_read(v3);
	hdmi_write(0x10010u, 0x52u);
	hdmi_write(0x10011u, 0x54u);
	hdmi_write(0x10012u, 0x41u);
	hdmi_write(0x10013u, 0x57u);
	hdmi_read(v4);
}
// 1B50: variables would overlap: w0.1 and x0.8

//----- (0000000000001C38) ----------------------------------------------------
int bsp_hdmi_cec_sta_check(void)
{
	char v0; // w19

	hdmi_write(0x10010u, 0x45u);
	hdmi_write(0x10011u, 0x45u);
	hdmi_write(0x10012u, 0x52u);
	hdmi_write(0x10013u, 0x54u);
	v0 = *(uint8_t *)(hdmi_base_addr + 32786);
	hdmi_write(0x10010u, 0x52u);
	hdmi_write(0x10011u, 0x54u);
	hdmi_write(0x10012u, 0x41u);
	hdmi_write(0x10013u, 0x57u);
	return -!(v0 & 1);
}

// nfuncs=27 queued=26 decompiled=26 lumina nreq=0 worse=0 better=0
//

void t507_hdmi_phy_init(uint_fast32_t dotclock)
{
	unsigned int vic = 31;
	bsp_hdmi_init();
	bsp_hdmi_video(vic);
}

#endif
